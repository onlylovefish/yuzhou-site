import{_ as o,c as i,b as t,a as s,e as r,d as n,r as c,o as l}from"./app-BKURSIeJ.js";const p="/yuzhou-site/assets/react%E5%8C%85%E6%9A%B4%E9%9C%B2%E6%96%B9%E6%B3%95-NQwKrXS8.png",d="/yuzhou-site/assets/%E5%86%85%E6%A0%B83%E4%B8%AA%E5%8C%85%E7%9A%84%E5%85%B3%E7%B3%BB-BbycARK6.png",m={};function u(h,e){const a=c("App");return l(),i("div",null,[e[2]||(e[2]=t("p",null,"学习一个源码仓库，肯定要先看看源码仓库的文件结构,react仓库基础包结构如下",-1)),e[3]||(e[3]=t("ol",null,[t("li",null,[t("strong",null,"react")])],-1)),e[4]||(e[4]=t("p",null,"react 基础包, 只提供定义 react 组件(ReactElement)的必要函数, 一般来说需要和渲染器(react-dom,react-native)一同使用. 在编写react应用的代码时, 大部分都是调用此包的 api.",-1)),e[5]||(e[5]=t("ol",{start:"2"},[t("li",null,[t("strong",null,"react-dom")])],-1)),t("p",null,[e[0]||(e[0]=r("react 渲染器之一, 是 react 与 web 平台连接的桥梁(可以在浏览器和 nodejs 环境中使用), 将react-reconciler中的运行结果输出到 web 界面上. 在编写react应用的代码时,大多数场景下, 能用到此包的就是一个入口函数ReactDOM.render(")),n(a),e[1]||(e[1]=r(", document.getElementById('root')), 其余使用的 api, 基本是react包提供的."))]),e[6]||(e[6]=s('<ol start="3"><li><p><strong>react-reconciler</strong> 核心包</p></li><li><p><strong>scheduler</strong></p></li></ol><p>调度机制的核心实现, 控制由react-reconciler送入的回调函数的执行时机, 在concurrent模式下可以实现任务分片. 在编写react应用的代码时, 同样几乎不会直接用到此包提供的 api.</p><h2 id="宏观总览" tabindex="-1"><a class="header-anchor" href="#宏观总览"><span>宏观总览</span></a></h2><h3 id="架构分层" tabindex="-1"><a class="header-anchor" href="#架构分层"><span>架构分层</span></a></h3><p>为了便于理解, 可将 react 应用整体结构分为接口层(api)和内核层(core)2 个部分</p><h4 id="接口层-api" tabindex="-1"><a class="header-anchor" href="#接口层-api"><span>接口层（api）</span></a></h4><p>react包，在react启动后，正常可以改变渲染的基本操作有3个</p><ul><li>class组件setState</li><li>function组件使用hook，dispatchAction改变hook对象</li><li>改变context</li></ul><p>setState和dispatchAction都是由react包直接暴露</p><img src="'+p+'" style="height:380px;width:200px;"><h4 id="内核层-core" tabindex="-1"><a class="header-anchor" href="#内核层-core"><span>内核层(core)</span></a></h4><p>内核分为3个部分</p><ol><li><p>调度器(scheduler) 只有一个核心职责：调度器将react-reconciler提供的回调函数，包装在一个任务对象中，在内部维护一个任务队列，优先级高的排在最前面，循环消费任务队列，直到队列清空</p></li><li><p>构造器(react-reconciler) 共有3个核心职责：装载渲染器，渲染器必须实现HostConfig协议，保证在需要的时候正确调用渲染器的api，生成实际节点（dom节点）；接收react-dom包（初次render）和react包（后续的setState）发起的更新请求；将fiber树的构造过程包装在一个回调函数中，并将回调函数传入scheduler包等待调度</p></li><li><p>渲染器(react-dom) 共有2个核心职责引导react应用的启动（reactDOM.render）；实现HostConfig协议，能够将react-reconciler包构造出来的fiber树表现出来，生成dom节点（浏览器）或者字符串(ssr)，新版在主要在<code>packages/react-dom-bindings/src/client/ReactFiberConfigDOM.js</code>中，可以理解为react和dom之间的翻译</p></li></ol><p><img src="'+d+'" alt="alt text"></p>',14))])}const f=o(m,[["render",u]]),b=JSON.parse('{"path":"/article/a7kim9gv/","title":"仓库结构","lang":"zh-CN","frontmatter":{"title":"仓库结构","createTime":"2025/07/20 22:40:48","permalink":"/article/a7kim9gv/"},"readingTime":{"minutes":2.28,"words":683},"git":{"createdTime":1753022727000,"updatedTime":1753627460000,"contributors":[{"name":"onlylovefish","username":"onlylovefish","email":"2511452548@qq.com","commits":3,"avatar":"https://avatars.githubusercontent.com/onlylovefish?v=4","url":"https://github.com/onlylovefish"}]},"filePathRelative":"sourceCode/react篇/仓库结构.md","headers":[],"categoryList":[{"id":"6459a8","sort":10000,"name":"sourceCode"},{"id":"d601c1","sort":10001,"name":"react篇"}]}');export{f as comp,b as data};
