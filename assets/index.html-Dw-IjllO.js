import{_ as i,c as a,a as e,o as n}from"./app-BKURSIeJ.js";const l="/yuzhou-site/assets/%E5%88%9B%E5%BB%BAeslint%E6%8F%92%E4%BB%B6-CoyyLYFo.png",t={};function h(p,s){return n(),a("div",null,s[0]||(s[0]=[e('<p>笔者今年的一个工作项就是在做团队项目的性能优化，这里提一个小点，內联样式在rn，react中在如下场景会有一定性能影响</p><ul><li>每次渲染都会新建一个 style 对象，如果这个对象作为 props 传递给子组件，会导致子组件无法利用 React.memo 等浅比较优化，从而产生不必要的渲染。</li><li>简单、静态的内联样式（如 <code>style={{height: 12}}）</code>影响极小，几乎可以忽略。</li></ul><p>为了让大家在业务迭代中减少这种书写，所以就想结合eslint插件功能，增加一些提示🔔</p><p>以下内容参考自<a href="https://zh-hans.eslint.org/docs/latest/extend/plugins" target="_blank" rel="noopener noreferrer">eslint插件</a></p><p>可以通过<a href="https://www.npmjs.com/package/generator-eslint" target="_blank" rel="noopener noreferrer"> Yeoman 生成器</a>创建一个插件</p><ol><li>安装generator-eslint</li></ol><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">npm</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> i</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> -g</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> generator-eslint</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ol start="2"><li>安装yo</li></ol><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">npm</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> i</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> -g</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> yo</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ol start="3"><li>执行创建</li></ol><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">yo</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> eslint:plugin</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>执行后得到如下交互式 <img src="'+l+`" alt="创建eslint插件"></p><p>插件的具体内容可以见<a href="https://github.com/onlylovefish/no-inline-style-plugin" target="_blank" rel="noopener noreferrer">no-inline-style-plugin</a></p><p>之前没有写过插件，此处补充一些eslint插件的知识</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">JSXAttribute</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">node</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // 这里的 node 就是 AST 里的 JSXAttribute 节点</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // 例如 &lt;Component style={{ color: &#39;red&#39; }} /&gt; 里的 style 属性</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你可以通过 node 访问这个属性的名字、值、类型等信息。 比如：</p><p>node.name.name 是属性名（如 &quot;style&quot;） node.value 是属性值（如 { color: &#39;red&#39; } 的 AST 表达） 总结： node 就是当前遍历到的语法结构的详细信息对象。你可以用它来判断、分析和定位代码中的具体内容。</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">create</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">context</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // context.report 用于报告错误</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // context.getSourceCode() 可以获取源码</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // context.options 获取规则参数</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>context是 ESLint 规则的上下文对象，由 ESLint 在运行你的规则时自动传入。它的作用是：</p><p>提供报告错误的方法（如 context.report） 提供获取配置信息的方法（如 context.options、context.settings） 提供获取源码的方法（如 context.getSourceCode()） 提供规则 ID、文件名等信息 常用的 context 属性有：</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">context</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">report</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">({...})</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">：</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">报告一个</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> lint</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> 错误</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">context</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">options</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">：</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">获取规则的自定义参数</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">context</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">getSourceCode</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">：</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">获取当前文件的源码对象</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">context</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">id</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">：</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">当前规则的</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> id</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">context</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">filename</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">：</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">当前文件名</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">（</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">部分版本支持</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="eslint的运行原理" tabindex="-1"><a class="header-anchor" href="#eslint的运行原理"><span>eslint的运行原理</span></a></h2><h3 id="解析为ast" tabindex="-1"><a class="header-anchor" href="#解析为ast"><span>解析为AST</span></a></h3><p>ESLint使用JavaScript解析器Espree把JS代码解析成AST。</p><p>PS：这里说明下，eslint本身并不做解析的事情，而是借助根据配置的parser选择对应的解析器，解析器将源码转为AST，eslint拿到AST后，运行配置规则</p><h3 id="遍历ast" tabindex="-1"><a class="header-anchor" href="#遍历ast"><span>遍历AST</span></a></h3><p>配置的规则遍历AST，做静态分析，报错或自动修复等</p><h3 id="触发监听选择器的rule回调" tabindex="-1"><a class="header-anchor" href="#触发监听选择器的rule回调"><span>触发监听选择器的rule回调</span></a></h3><p>在深度遍历的过程中，生效的每条规则都会对其中的某一个或多个选择器进行监听，每当匹配到选择器，监听该选择器的rule，都会触发对应的回调。</p><p>PS：这里的选择器指的是Eslint规则中用于匹配AST节点类型的名称，本质就是你想监听的语法结构的类型</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">create</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">context</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">  return</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // 这里的 JSXAttribute 就是“选择器”</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">    JSXAttribute</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">node</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">      // 只要遍历到 AST 中的 JSXAttribute 节点，就会触发这个回调</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    },</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // 你也可以监听其他类型</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">    VariableDeclaration</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">node</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> ...</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> },</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">    FunctionDeclaration</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">node</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> ...</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> },</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // 还可以写更复杂的选择器</span></span>
<span class="line"><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">    &quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">CallExpression[callee.name=&#39;setTimeout&#39;]</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">node</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> ...</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">  }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="其他思考" tabindex="-1"><a class="header-anchor" href="#其他思考"><span>其他思考</span></a></h2><h3 id="大模型可以未来替换或者做一些eslint的事情吗" tabindex="-1"><a class="header-anchor" href="#大模型可以未来替换或者做一些eslint的事情吗"><span>大模型可以未来替换或者做一些eslint的事情吗</span></a></h3><p>随着大模型的发展，是不是一些eslint插件的逻辑可以通过mcp rules来配置</p><p>个人理解，如果一些比较自定义的小规则可以通过大模型来搭配实现，相对更加简单，无需写更复杂的插件内容，但目前来看大模型的规则还不够可控和稳定，对于团贵强制规范，自动修复等场景，传统的eslint插件更可靠</p><h3 id="eslint会做解析-webpack也会有ast解析-他们会是同一份吗" tabindex="-1"><a class="header-anchor" href="#eslint会做解析-webpack也会有ast解析-他们会是同一份吗"><span>eslint会做解析，webpack也会有ast解析，他们会是同一份吗</span></a></h3><p>ESLint 和 Webpack 都会将 JS 代码解析为 AST，但它们各自有独立的解析过程，通常不会复用同一个 AST。</p><ul><li><p>ESLint ESLint 会用自己的解析器（默认是 Espree，也可以用 babel-eslint、@typescript-eslint/parser 等）把每个 JS 文件单独解析为 AST，然后基于 AST 运行规则检测和修复。</p></li><li><p>Webpack Webpack 本身不会直接解析 JS 为 AST，而是依赖于 loader（如 babel-loader）或插件（如 terser-webpack-plugin、eslint-webpack-plugin）来处理 AST。 如果用到 Babel，Babel 会解析为 AST 并转换代码，但这个 AST 只在 Babel 处理流程中用，不会自动传递给 ESLint。</p></li><li><p>是否复用？ 一般情况下，ESLint 和 Webpack/Babel 各自独立解析源码，互不复用 AST。 只有在特殊插件（如 eslint-loader、eslint-webpack-plugin）中，才可能在 Webpack 构建流程中调用 ESLint，但即使如此，ESLint 还是会自己重新解析源码。</p></li></ul><p>为什么不复用？ AST 结构和需求不同（比如 Babel 的 AST 和 ESLint 的 AST 结构有差异）。 插件和工具链解耦，方便独立升级和维护。 解析器可配置，ESLint 支持多种解析器，适配不同语法。</p>`,39)]))}const r=i(t,[["render",h]]),d=JSON.parse('{"path":"/article/fgga4084/","title":"eslint插件-內联style提示","lang":"zh-CN","frontmatter":{"title":"eslint插件-內联style提示","createTime":"2025/07/06 13:32:52","permalink":"/article/fgga4084/"},"readingTime":{"minutes":4.39,"words":1318},"git":{"createdTime":1751794829000,"updatedTime":1751794829000,"contributors":[{"name":"onlylovefish","username":"onlylovefish","email":"2511452548@qq.com","commits":1,"avatar":"https://avatars.githubusercontent.com/onlylovefish?v=4","url":"https://github.com/onlylovefish"}]},"filePathRelative":"practice/eslint插件-內联style提示.md","headers":[],"categoryList":[{"id":"8c4040","sort":10002,"name":"practice"}]}');export{r as comp,d as data};
