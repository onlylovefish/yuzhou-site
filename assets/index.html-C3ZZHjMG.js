import{_ as t,c as i,a as o,o as p}from"./app-BKURSIeJ.js";const s="/yuzhou-site/assets/cli%E5%8D%A1%E6%8E%A7%E6%88%AA%E5%9B%BE-D4pu4w9e.png",a="/yuzhou-site/assets/%E5%AF%BB%E6%89%BErn%E6%8A%A5%E9%94%99-CWzUQZgA.png",c="/yuzhou-site/assets/%E5%AF%BB%E6%89%BErn%E5%9C%B0%E5%9D%80%E7%9A%84%E4%BB%A3%E7%A0%81%E8%A1%8C-CK-f_iJh.png",r={};function m(n,e){return p(),i("div",null,e[0]||(e[0]=[o('<p>本周我们仓库在做一个quickJS引擎的应用，需要升级基建cli，发现了几个问题，所以那就梳理下吧～</p><p>先说下问题</p><ol><li>当前仓库的monorepo结构下无法单包升级cli，会提示存在多版本共存问题，导致无法构建</li><li>其中试点子包会出现依赖的msi版本冗余打包问题</li><li>msi幽灵依赖问题</li></ol><p>我们的仓库之前做过一次monorepo的基建改造，部分包做了子包安装，有些又在根目录锁包，因为有些是迁移的整体依赖管理不是非常好</p><p>针对这几个问题做了下排查</p><p>先说第一个问题，无法单包升级cli，因为属于基建升级，所以是期望先在其中某些子包做试点，选择的这个子包，我们发现升级这个子包A的cli到3.1.9后，不仅这个子包A不能构建了，monorepo下其他子包无法构建了，排查发现因为这个项目下其实因为之前的升级和一些历史遗留问题，再加上我们这次又引入了一个版本，整个项目下存在多个cli版本，在cli中有个卡控,如下图所示</p><p><img src="'+s+'" alt="alt text"></p><p>在多版本不匹配的情况下，会直接<code>process.exit(0)</code>,而不会接下去执行，看了下后面的执行流程，多版本对构建本身不存在影响，所以先对cli进行patch，将该部分的代码注释掉，并且添加一行打印，等所有子包升级后就不会存在多版本，自然也就不需要patch了</p><p>其实这里还存在一个问题，因为我们之前从3.0.4-7升级到3.0.8-rome.8并不需要给3.0.8-rome.8打patch，为什么这次需要呢，其实还是从上面截图中看，这里匹配用的是```semver.satisfies，这个函数对于小版本中的升级其实是不影响的，但是因为我们这里直接升级了中版本号，所以会走进这个if条件，从而命中卡控</p><p>问题2，msi的冗余打包</p><p>当前的cli工具中对于monorepo的支持不是很好，它无法寻找根目录的依赖，因为cli需要寻找rn依赖，我们这次的试点子包没有在子包的 <code>package.json</code>中直接依赖，实际用的算是幽灵依赖，用了根目录的rn <img src="'+a+'" alt="alt text"><img src="'+c+'" alt="alt text"> 所以为了解决这个问题，和基建侧沟通，他们暂不修改，只能我们自己先解决，看了下只能我们在子包中安装rn</p><p>此时就引出了我们这个问题，构建后在sourcemap中发现msi出现了冗余打包，那这个是什么原因呢，我们发现有两个msi，其中一个是1.15.0一个是1.56.2-beta.0，看了这两个依赖的依赖发现他们的peerDev中有rn，而我们仓库中没有锁定msi的版本，所以会引入两个冗余包，分别是<code>@mtfe+msi@1.15.0_@mrn+react-native@3.0.21，@mtfe+msi@1.56.2-beta.0_@mrn+react-native@3.0.21</code></p><p>第三个问题，msi的幽灵依赖</p><p>我们发现因为我们另一个子包B，它根本不直接依赖msi，但是也安装了1.56.2-beta.0这个版本，看了下之前的版本都是1.15.0，所以怀疑是用了兄弟包的幽灵依赖，测试了下将兄弟的包改为1.57.2-beta.0，B的构建中也变成了1.57.2-beta.0，那我们该怎么解决呢，其实他之前可能存在一些依赖的依赖是1.15.0,所以考虑直接在其<code>package.json</code>中显式声明这个1.15.0版本，这样他就不会用兄弟的幽灵依赖</p><p>其他思考🤔</p><p>我翻了下这个子包B的构建，发现从2024年底到2025.7这个包逐渐增大了100KB+，其实在隐形中包一直在变大，而这其实会影响页面的性能，所以业务开发中需要每次关注构建包的体积问题</p><p>基建的升级存在一些中间态，比如这次先尝试一个子包，那就会存在一些尴尬期，和理想态不符合的情况，比如cli存在多版本，依赖存在一些冗余等等，之前升级也遗留了一些没有做完的事情，比如之前的patch最后并没有完全清理掉等等，个人觉得，中间态必然存在，但是需要记得后续让他成为理想态，不然就会存在一个混乱💥的仓库，和永远的阵痛，这也不敢改，那也不敢改</p><p>其实这里面还存在一个问题，公司的一些基建考虑不是很完善，比如他们没有考虑到monorepo的场景，有些依赖其实我们确实可以在根目录去锁包，2而不需要每个子包安装的情况，还有msi这种无法tree-shaking的尴尬设计，随着版本的升级，这玩意体积一直在膨胀，真是忍不住喷啊～，所以基建团队也需要去思考，怎么给业务使用时是一个平和的使用，去真的接触业务的各种组织形式，或者给业务一些最佳实践的组织形式</p><p>2025.07.29补充</p><p>似乎当前metro整体对pnpm的支持不是很好，对monorepo格式下的依赖索引也存在一些问题，之前社区也遗留很多坑，企业中因为最初从某个版本切出，后续自己魔改了很多，后续社区的一些新特性，或者bug修复想合并进去，就很困难</p>',20)]))}const E=t(r,[["render",m]]),d=JSON.parse('{"path":"/practice/%E4%BE%9D%E8%B5%96/","title":"依赖","lang":"zh-CN","frontmatter":{"title":"依赖","createTime":"2025/07/27 15:50","permalink":"/practice/依赖/"},"readingTime":{"minutes":4.89,"words":1467},"git":{"createdTime":1753609318000,"updatedTime":1753805144000,"contributors":[{"name":"onlylovefish","username":"onlylovefish","email":"2511452548@qq.com","commits":2,"avatar":"https://avatars.githubusercontent.com/onlylovefish?v=4","url":"https://github.com/onlylovefish"}]},"filePathRelative":"practice/依赖.md","headers":[],"categoryList":[{"id":"8c4040","sort":10002,"name":"practice"}]}');export{E as comp,d as data};
