---
title: 性能评价指标
createTime: 2025/06/24 23:29:37
permalink: /article/7vp44brm/
---

## RCF评价体系
我司建设了一份评价指标，RCF（A），主要含义如下

| 指标 | 含义 | 落地计算 |
| --- | --- | --- |
| R（response） | 响应时延<br/>主要影响用户对触控交互及时性，控制感和愉悦性的体验评价<br/>简单说就是避免让用户感受到明显的系统延迟 | 响应从发出指令后到屏幕产生明显变化的第一帧之前<br/>衡量指标：系统响应时长<br/>检测：从用户输入产生手势事件到事件被主线程消费结束之间的时间 |
| C（completion） | 完成时延<br/>包括响应时延、动效时长以及内容加载时间，反应的是用户对响应速度的整体感觉 | 从发出指令到内容全部稳定显示<br/>衡量指标：页面完成时长<br/>以首屏图片加载完成并且元素稳定不再变化为页面加载完成时间点 |
| F（follow） | 最大连续丢帧数<br/>反应用户感受到画面不连贯，卡顿的程度，越接近0越好 | 页面滑动过程中，用户感受到画面不连贯，卡顿的程度，指标是连续丢帧数<br/>最小FPS(minFPS)(页面滚动时每隔1s计算一次FPS取最小值)+最大连续丢帧数（最多连续未绘制帧数） |
| A（animation） | 动效时延<br/>反应的是新页面打开或者控件出现过程的时间长短，主要是C端一些动画的效果 | 动效持续时间，目前没有指标的监控，靠设计验收和人工体感 |

### RCF采集
| 指标 | 采集方法 | 对标 |
| --- | --- | --- |
| R | MRN（Android）<br/>MRN的事件交互需要经过Native侧->JS侧->Native侧多轮，整体思路为“追随”点击事件的流转，直到点击事件被JS消费并且点击事件修改的布局在UI线程完成更新，此时的时间减去开始时间即为交互响应时间<br/>MRN（IOS） | 腾讯-metrix<br/>阿里百川<br/>[FID（首次输入延迟）](https://developer.mozilla.org/zh-CN/docs/Glossary/First_input_delay) |
| C指标 | C指标选取的是FSP指标作为数据来源，统计页面加载时间时会考虑首屏元素的稳定和网络图片的加载 | LCP（最大内容绘制） |
| F | 传统滚动流畅度是从单一的角度反映页面的滚动流畅度，比如我们熟悉的FPS是从平均值的角度反映整个页面使用过程中平均的FPS，降速则是关注帧率发生突变的时候从稳定性的角度反映页面滚动流畅度。该指标做了结合：最小FPS+最大连续丢帧 | FPS：1s内页面刷新的次数<br/>腾讯：perfDog |

### 单个指标的得分计算
参考Apdex标准，指标样本分为三类：满意、可容忍、不可接受

单指标Apdex指数=（满意样本*1+可容忍样本*0.5+不可接受样本*0）/样本总数

页面单指标得分MetricScore=Apdex指数*100

因为指标Apdex阈值制定时考虑到高/中/低端机型用户在日常使用过程中对体验感知存在明显差异，所以高、中机型的阈值会比低端机更严格

#### R指标评分
| 机型/评级 | 满意 | 可容忍 | 不可接受 |
| --- | --- | --- | --- |
| 所有机型 | <=100ms | 100-150ms | >150ms |

#### C指标
| 机型/评级 | 满意 | 可容忍 | 不可接受 |
| --- | --- | --- | --- |
| 高 | 300-400ms | 400-1000ms | >1000ms |
| 中 | 300-600ms | 600-1000ms | |
| 低 | 300-800ms | 800-1000ms | |

#### F指标（最小帧率+最大连续丢帧）
| 机型/评级 | 满意 | 可容忍 | 不可接受 |
| --- | --- | --- | --- |
| 高 | 最小FPS>=58+最大连续丢帧<=1帧 | 58>最小FPS>=55+最大连续丢帧<=1帧 | 最大连续丢帧>1帧<br/>或最小FPS<55/53/50 |
| 中 | 最小FPS>=55+最大连续丢帧<=1帧 | 55>最小FPS>=53+最大连续丢帧<=1帧 | |
| 低 | 最小FPS>=53+最大连续丢帧<=1帧 | 53>最小FPS>=50+最大连续丢帧<=1帧 | |

#### 页面综合得分计算
RCF的权重是0.2:0.5:0.3，各个占比✖️各个指标的分数

共计5个等级

- 0<=x<20 非常不流畅
- 20<=x<40 不流畅
- 40<=x<60 一般
- 60<=x<80 流畅
- x>80 非常流畅

---

## web常见的评价指标

### Core Web Vitals核心web指标
| 指标名称 | 定义 | 衡量目标 | 良好阈值 |
| --- | --- | --- | --- |
| 最大内容绘制（LCP） | 页面加载过程中，最大可见内容元素（如图片、文本块）完成渲染的时间。 | 评估页面 “加载速度” 的核心指标。 | 首次内容绘制后 2.5 秒内 |
| 交互下的最大延迟（INP） | 用户与页面交互（如点击、滑动、输入）过程中，所有交互响应延迟的最大值。 | 评估页面 “交互流畅度” 的核心指标。 | 所有交互的最大延迟≤200 毫秒 |
| 累积布局偏移（CLS） | 页面加载和交互过程中，可见元素位置意外偏移的累积分数（布局稳定性）。 | 评估页面 “视觉稳定性” 的核心指标。 | 页面生命周期内 CLS≤0.1 |

### 加载性能指标
#### 基础加载时间指标
- 白屏时间
- 首屏加载时间
- 首次内容绘制（FCP）

#### 网络与后端相关
- 首字节时间：从浏览器发起请求到接收到服务器返回的第一个字节的时间。
- DNS解析时间：域名解析为 IP 地址的耗时（如从 `www.example.com` 解析到具体 IP）。可通过 DNS 预解析、CDN 优化缩短。
- TCP连接时间

#### 交互与渲染性能指标
**交互响应指标**
- 首次输入延迟（FID，已被 INP 替代，但仍有参考价值）：用户首次交互（如点击按钮）到浏览器开始处理该事件的时间。反映主线程是否被阻塞。
- 总阻塞时间（TBT）：页面加载过程中，主线程阻塞时间超过 50 毫秒的总时长。阻塞时间越长，用户交互越容易卡顿。

**渲染流畅度指标**
- 帧率（FPS）：页面每秒渲染的帧数，理想值为 60FPS（每帧≈16.7 毫秒）。低于 30FPS 会让滚动、动画等操作显得卡顿（如 H5 游戏、复杂表单交互）。
- 绘制时间（Paint Time）：浏览器执行 “绘制” 操作（将布局结果转换为像素）的耗时。频繁大量绘制（如无节流的滚动事件）会导致帧率下降。
- 布局偏移率（Layout Shift）：单个元素布局偏移的分数（CLS 的组成部分）。例如，图片未设置尺寸导致加载后突然撑开布局，会引发用户误触。

#### 资源与效率指标
**资源加载效率**
- 资源总大小：页面所有资源（HTML、CSS、JS、图片、字体等）的总字节数。过大的资源会增加带宽消耗，拖慢加载（移动端弱网环境更明显）。
- 请求数：页面加载过程中发起的 HTTP/HTTPS 请求总数。过多请求会增加 TCP 连接开销，可通过资源合并（如 JS/CSS 合并）、雪碧图减少。
- 图片 / 视频优化指标：
    - 图片压缩率（实际大小 / 原始大小）：未压缩的大图是加载性能杀手。
    - 延迟加载覆盖率：非首屏图片是否启用延迟加载（减少初始请求）。

**JavaScript 执行效率**
- 长任务时间（Long Tasks）：主线程中执行时间超过 50 毫秒的任务（如复杂计算、未优化的循环）。长任务会阻塞 UI 渲染和事件响应，导致交互卡顿。
- JS 解析 / 编译时间：浏览器解析和编译 JavaScript 代码的耗时。过大的 JS 文件（如未拆分的单页应用）会延长这一时间。

**缓存效率**
- 缓存命中率：从缓存（HTTP 缓存、Service Worker 缓存）中获取资源的请求占比。高命中率可减少重复下载，提升二次加载速度。

### 可用性与稳定性指标
衡量页面功能可用性和运行稳定性，避免因性能问题导致功能失效。

- JS 错误率：页面运行过程中未捕获的 JavaScript 错误数量占比。错误会导致功能异常（如按钮点击无响应）。
- 资源加载失败率：CSS、JS、图片等资源加载失败的请求占比。失败会导致页面样式错乱、功能缺失。
- 内存占用：页面运行时的内存消耗（如 DOM 节点数量、JS 对象占用）。内存泄漏会导致页面卡顿、崩溃（尤其长时间运行的 H5 应用）。
- CPU 使用率：页面运行时对设备 CPU 的占用率。过高会导致设备发烫、续航下降（移动端 H5 需重点关注）。

### 部分指标测量方式
#### 白屏时间
白屏时间 = 首次出现非空白内容的时间 - 页面开始加载的时间

```javascript
// 记录页面开始加载的时间
const startTime = performance.timing.navigationStart;

// 记录首个可见内容出现的时间
const firstContentTime = performance.now() + startTime;
// 计算白屏时间（毫秒）
const whiteScreenTime = firstContentTime - startTime;
console.log("白屏时间：", whiteScreenTime, "ms");
```

方式二，利用 performance API

```javascript
window.addEventListener('load', function() {
  const timing = performance.timing;
  const firstPaint = performance.getEntriesByName('first-paint')[0]?.startTime || 0;
  const whiteScreenTime = firstPaint - timing.navigationStart;
  console.log("白屏时间（基于首次绘制）：", whiteScreenTime, "ms");
});
```

- `performance.timing.navigationStart`：浏览器开始处理当前页面的时间（在 URL 输入后开始导航时触发）。
- `performance.now()`：返回相对于页面加载起始点的高精度时间（毫秒），比 `Date.now()` 更准确。
- `domLoading`：浏览器开始解析 HTML 文档的时间（此时页面仍是空白）。
- `domInteractive`：HTML 解析完成，但外部资源（如 CSS、JS）可能未加载完成的时间（可能已有部分内容渲染）。
- `firstPaint`（首次绘制）：浏览器首次绘制像素的时间（包括背景色、边框等，是白屏结束的标志）。
- `first-paint`（FP）是浏览器官方定义的 “首次绘制” 指标，代表页面从空白到首次出现任何像素的时间，与白屏时间的含义高度吻合。
- 需注意：`performance.getEntriesByName('first-paint')` 在部分旧浏览器（如 IE）中不支持，建议配合兼容性处理。

![](https://cdn.nlark.com/yuque/0/2025/png/1978502/1756025274553-db2d4fd0-2fbb-4a64-a842-f8fe73507726.png)

还可以利用 chrome tools