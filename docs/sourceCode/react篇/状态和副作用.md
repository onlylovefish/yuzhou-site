---
title: 状态和副作用
createTime: 2025/11/09 18:15:13
permalink: /article/lv2hr4j8/
---
本节主要分析fiber如果影响最终的渲染

Fiber树众多属性，有两块内容
1. fiber节点的自身状态，在renderRootSync【Concurrent】阶段，为子节点提供确定的输入数据，影响子节点生成
2. fiber节点的副作用：在commitRoot阶段，如果fiber被标记有副作用，则副作用相关函数会（同步/异步）被调用

```js
export type Fiber = {|
  // 1. fiber节点自身状态相关
  pendingProps: any,
  memoizedProps: any,
  updateQueue: mixed,
  memoizedState: any,

  // 2. fiber节点副作用(Effect)相关
  flags: Flags,
  subtreeFlags: Flags, // v17.0.2未启用
  deletions: Array<Fiber> | null, // v17.0.2未启用
 
|};
```

## pendingProps
fiber.pendingProps: 输入属性, 从ReactElement对象传入的 props. 它和fiber.memoizedProps比较可以得出属性是否变动.

## memoizedProps
fiber.memoizedProps: 上一次生成子节点时用到的属性, 生成子节点之后保持在内存中. 向下生成子节点之前叫做pendingProps, 生成子节点之后会把pendingProps赋值给memoizedProps用于下一次比较.pendingProps和memoizedProps比较可以得出属性是否变动

## updateQueue 的主要功能
1. 管理 hooks 的副作用链表
对于函数组件，updateQueue 里保存了 hooks 的 effect 环形链表（如 useEffect、useLayoutEffect 等）。

结构通常是 { lastEffect: Effect | null }，每个 effect 通过 next 字段串成环。

2. 管理 hooks 的 state 更新队列

对于 useState、useReducer 等 hooks，updateQueue 还会存储 state 的更新队列（链表），用于调度和合并多次 setState。

3. 存储其它 hooks 相关的数据
例如 stores（用于 useSyncExternalStore）、memoizedState（hooks 链表头）等。

## memoizedState
fiber.memoizedState: 上一次生成子节点之后保持在内存中的局部状态.

## 外部api

### 类式组件
```js
class App extends React.Component {
  constructor() {
    this.state = {
      // 初始状态
      a: 1,
    };
  }
  changeState = () => {
    this.setState({ a: ++this.state.a }); // 进入reconciler流程
  };

  // 生命周期函数: 状态相关
  static getDerivedStateFromProps(nextProps, prevState) {
    console.log('getDerivedStateFromProps');
    return prevState;
  }

  // 生命周期函数: 状态相关
  shouldComponentUpdate(newProps, newState, nextContext) {
    console.log('shouldComponentUpdate');
    return true;
  }

  // 生命周期函数: 副作用相关 fiber.flags |= Update
  componentDidMount() {
    console.log('componentDidMount');
  }

  // 生命周期函数: 副作用相关 fiber.flags |= Snapshot
  getSnapshotBeforeUpdate(prevProps, prevState) {
    console.log('getSnapshotBeforeUpdate');
  }

  // 生命周期函数: 副作用相关 fiber.flags |= Update
  componentDidUpdate() {
    console.log('componentDidUpdate');
  }

  render() {
    // 返回下级ReactElement对象
    return <button onClick={this.changeState}>{this.state.a}</button>;
  }
}
```
### 函数式组件
函数式组件和类组件最大的不同是，类组件会实例化一个instance，所以拥有独立的局部状态，而function组件不会实例化，只是被直接调用，所以不能维护一份独立的局部状态，只能依靠Hook对象间接实现局部状态，hook常用的有useState、useEffect、useLayoutEffect
```js
// useState/useReducer hook
{
  memoizedState, // 当前 state
  baseState,
  baseQueue,
  queue,         // 更新队列
  next           // 指向下一个 hook
}

// useEffect/useLayoutEffect hook
{
  memoizedState: {
    // effect 对象链表头
    lastEffect
  },
  queue,         // effect 队列
  next           // 指向下一个 hook
}
// effect 对象结构（useEffect/useLayoutEffect）
{
  tag,           // effect 类型（如 HookPassive、HookLayout）
  create,        // 副作用函数
  destroy,       // 清理函数
  deps,          // 依赖数组
  next           // 指向下一个 effect（环形链表）
}
```

## 补充说明
1. useEffect(function(){}, [])中的函数是异步执行, 因为它经过了调度中心(具体实现可以回顾调度原理).

2. useLayoutEffect和Class组件中的componentDidMount,componentDidUpdate从调用时机上来讲是等价的, 因为他们都在commitRoot->commitLayoutEffects函数中被调用.此时dom已经被更新，但是还没有绘制到页面

3. useEffect 的副作用是在 commit 阶段的被动（Passive）阶段调用的，具体流程如下：
```js
// commitRoot 阶段会先依次执行：
// commitBeforeMutationEffects
// commitMutationEffects
// commitLayoutEffects
// flushSpawnedWork
// useEffect 的副作用不会在上述同步阶段执行，而是会在最后通过调度一个异步任务（通常是微任务或宏任务），在浏览器完成绘制（paint）之后执行。
// 具体代码入口是 flushPassiveEffects，它会遍历所有带有 HookPassive 标记的 effect（即 useEffect），并执行它们的副作用函数。

// useLayoutEffect：在 DOM 更新后、浏览器绘制前同步执行，和 componentDidMount/componentDidUpdate 等价。
// useEffect：在浏览器完成绘制（paint）后异步执行，不会阻塞页面渲染。
```



hook相关可以看ReactFiberHook