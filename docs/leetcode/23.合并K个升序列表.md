---
title: 合并K个升序列表
createTime: 2025/08/04 23:00
permalink: /article/合并K个升序列表/
---
[合并K个升序列表](https://leetcode.cn/problems/merge-k-sorted-lists/)

该题需要学会的是分治，特点是当发现从2个到多个的合并这种，也有点类似堆算法？

两个的合并
```js
const mergeTwoLists=(a,b)=>{
   
    if(a==null||b==null){
        return a!==null?a:b
    }

    const head=new ListNode(0)
    let tail=head,aPtr=a,bPtr=b
    
    while(aPtr!==null&&bPtr!==null){
       
        if(aPtr.val<bPtr.val){
            tail.next=aPtr
            aPtr=aPtr.next
           
        }else{
            tail.next=bPtr
            bPtr=bPtr.next
        }
        tail=tail.next
    }
    tail.next = (aPtr != null ? aPtr : bPtr);
    
    return head.next
}
```

合并多个
```js
const merge=(lists,l,r)=>{
    if(l==r){
        return lists[l]
    }
    if(l>r){
        return null
    }

    const mid=(l+r)>>1

    /**
     * 这个可以拆分写
     * const L1 = merge(lists, l, mid);
     * const L2 = merge(lists, mid + 1, r);
     * return mergeTwoLists(L1, L2);
     */
    return mergeTwoLists(merge(lists,l,mid),merge(lists,mid+1,r))
}

var mergeKLists = function(lists) {
    return merge(lists,0,lists.length-1)
};
```

这道题有几个坑点，之前我在处理```tail.next = (aPtr != null ? aPtr : bPtr);```这块时，通过if条件写的，但是这种写法某些case会出现超时，<strong>原因在于两个 if 条件会导致最后 tail.next 指向的是 bPtr（如果 aPtr 和 bPtr 都不为 null），而不是只连接剩下的那一条链表。</strong>
```js
if(aPtr!==null){
    tail.next=aPtr
}
if(bPtr!==null){
    tail.next=bPtr
}
```

 ```const mid=(l+r)>>1```代表的是```mid=left+(right-left)/2```

 const mid = (l + r) >> 1 和 const mid = l + ((r - l) / 2)（或 l + Math.floor((r - l) / 2)）本质上是一样的，都是求区间中点。

>> 1 是右移一位，相当于除以 2 并向下取整。
l + ((r - l) / 2) 也能得到中点，但需要注意 JS 的 / 结果是浮点数，通常要用 Math.floor 取整。

但是最好要写成const mid = Math.floor((l + r) / 2);，安全起见

